fileID = fopen('input.txt', 'r');    % открытие входного файла
% Вычисление B <= N базисных (линейно независимых) из K входных векторов
% аналогом метода Гаусса
tline = fgetl(fileID);    % считывание первой строки
N = length(tline);    % вычисление N
array_basis_numbers = zeros(1, N);    % массив базисных векторов
presence_basis_numbers = false(1, N);    % массив флагов базисных векторов
B = 0;    % начальное число базисных векторов
while ~isequal(tline, -1) && B < N    % пока считаны не все входные строки и вычислен неполный базис
    number = bin2dec(tline);    % вычисление текущего вектора
    for i = 1:N    % перебор всех битов текущего вектора
        if bitget(number, i) == 1    % если i-ый бит текущего вектора - единица
            if presence_basis_numbers(i)    % если имеется базисный вектор, отвечающий за i-ый бит
                number = bitxor(number, array_basis_numbers(i));    % зануление i-ого бита в текущем векторе
            else    % иначе - если отсутствует базисный вектор, отвечающий за i-ый бит
                array_basis_numbers(i) = number;    % базисный вектор, отвечающий за i-ый бит - текущий вектор
                presence_basis_numbers(i) = true;    % выставить i-ый флаг базисных векторов
                B = B + 1;    % увеличение числа базисных векторов на единицу
                break;
            end
        end
    end
    tline = fgetl(fileID);    % считывание cледующей строки
end
fclose(fileID);    % закрытие входного файла
basis_numbers = array_basis_numbers(presence_basis_numbers);    % вычисление базисных векторов
% Вычисление весового спектра
weight_spectrum = zeros(1, N + 1);    % инициализация начального весового спектра нулями
weight_spectrum(1) = 1;    % учёт нулевого вектора
number = 0;    % начальный вектор
% Этот цикл можно распараллелить - разбить всё множество 0..(2^B - 2) на
% нужное число последовательных непересекающихся частей, в каждой из
% которых проинициализировать свой начальный вектор и тогда их можно выполнять
% параллельно, а в конце просто сложить полученные весовые спектры частей
for i = 0:(2 ^ B - 2)    % перебор оставшихся (2^B - 1) векторов, используя код Грея
    number = bitxor(number, basis_numbers(log2(bitxor(i, i + 1) + 1)));    % вычисление следующего вектора, log2((i xor (i + 1)) + 1) - индекс бита, который меняется в G(i + 1) относительно G(i)
    weight_vector = nnz(bitget(number, 1:N));    % вычисление веса текущего вектора
    weight_spectrum(weight_vector + 1) = weight_spectrum(weight_vector + 1) + 1;    % добавление веса текущего вектора в весовой спектр
end
% Вывод весового спектра в выходной файл
fileID = fopen('output.txt', 'w');    % открытие выходного файла
for i = 1:(N + 1)    % перебор всех возможных весов векторов
    fprintf(fileID, '%u\t%u\n', i - 1, weight_spectrum(i));    % вывод текущей пары веса и количества
end
fclose(fileID);    % закрытие выходного файла
% Ресурсы:
%         1) Память - O(N)
%         2) Время - O(N * (K + 2^B)), более грубо (в худшем случае) - O(N * 2^N)
% Ограничение реализации - N <= 64, так как вектора хранятся как числа, но
% так как время - экспоненциально, то в общем (худшем) случае при N > 64 весовой
% спектр за разумное время не вычислится
